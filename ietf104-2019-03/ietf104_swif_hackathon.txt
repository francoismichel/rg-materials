IETF 104 SWIF Codec Hackathon
=============================

Saturday and Sunday, March 3-4, 2018, starting at 9:00, Grand Ballroom

-   [Hackathon
    wiki](https://trac.ietf.org/trac/ietf/meeting/wiki/104hackathon)\
-   [Github swif-codec repo](https://github.com/irtf-nwcrg/swif-codec)

Expected participants
---------------------

-   Vincent Roca
-   Marie-Jose Mbntpetit (Saturday)
-   Fran√ßois Michel
-   Kazuhisha Matsuzono
-   Cedric Adjih
-   Oumaima Attia
-   ???

General topics to be discussed and agreed on
--------------------------------------------

### Licencing considerations:

-   Do all contributors agree to use a BSD licence?
-   Do all the authors of existing code reused by the SWIF codec
    (Cedric/Vincent/...) agree to switch to a BSD licence?

### SWIF Codec project targets:

To be discussed: \* Focus on an RLC codec first (as per [RLC
I-D](https://datatracker.ietf.org/doc/draft-ietf-tsvwg-rlc-fec-scheme/)),
the RLNC codec will be addressed as a second step (it will share a lot
of code anyway. \* Design the SWIF Codec + tiny C language server
(encoding side)/client (decoding side) application. \* Add a Python
wrapper to the SWIF Codec, then Python test and simulation applications.

### Strategy

-   Work on encoder first, with an operational SWIF encoder + server
    application. Add unitary tests for the encoder.
-   Then work on decoder and test the whole chain: server - client. Add
    unitary tests for the decoder and the whole chain.
-   In parallel, work on Python wrapper and python applications.

Tasks
-----

### SWIF Codec, encoder:

-   T1.01: glue between the generic API and RLC codec: the generic API
    is the one shared by all the SWIF codecs, an RLC flavor is needed as
    well as a link between the two ones.
-   T1.02: work on GF(2\^8) math library: reuse gardinet lib, understand
    how to use it, see if something is missing.
-   T1.03: work on encoder\_create()
-   T1.04: work on encoder\_release()
-   T1.05: work on encoder\_set\_callback\_functions()
-   T1.06: work on swif\_encoder\_set/get\_parameters()
-   T1.07: work on swif\_build\_repair\_symbol(): requires to generate
    the coding coefficients (see RLC I-D) and to computate of the linear
    combination.
-   T1.08: work on encoder\_reset\_coding\_window()
-   T1.09: work on encoder\_add\_source\_symbol\_to\_coding\_window()
-   T1.10: work on
    encoder\_remove\_source\_symbol\_from\_coding\_window()
-   T1.11: work on encoder\_get\_coding\_window\_information()
-   T1.12: work on encoder\_set\_coding\_coefs\_tab()
-   T1.13: work on swif\_encoder\_generate\_coding\_coefs()
-   T1.14: work on encoder\_get\_coding\_coefs\_tab()

### SWIF Codec, decoder:

-   T2.01: work on new source or repair symbol reception
-   T2.02: linear system decoding using the GF(2\^8) math library:
    includes linear system representation (C structure), progressive
    decoding upon receiving repair symbols involving erased source
    symbol(s)
-   T2.03: work on decoder\_create()
-   T2.04: work on decoder\_release()
-   T2.05: work on set\_callback\_functions()
-   T2.06: work on decoder\_set/get\_parameters
-   T2.07: work on decoder\_decode\_with\_new\_source\_symbol(): relies
    on work done on task "linear system decoding"
-   T2.08: work on decoder\_decode\_with\_new\_repair\_symbol(): relies
    on work done on task "linear system decoding"
-   T2.09: work on decoder\_reset\_coding\_window()
-   T2.10: work on decoder\_add\_source\_symbol\_to\_coding\_window()
-   T2.11: work on
    decoder\_remove\_source\_symbol\_from\_coding\_window()
-   T2.12: work on decoder\_set\_coding\_coefs\_tab()
-   T2.13: work on decoder\_generate\_coding\_coefs()

### SWIF Codec unitary test:

-   T3.1: find a way to add unitary tests.
-   T3.2: add as many unitary tests as possible for the encoder.
-   T3.3: add as many unitary tests as possible for the decoder.
-   T3.4: add as many unitary tests as possible for the server/client
    transmission.

### C-language server/client application:

-   T4.1: work on server (i.e., the encoding/sending side): requires to
    design a trivial packet format (transmission of the FEC OTI can be
    static on the opposite), set up the UDP connection, design a simple
    rate control scheme (to avoid saturating the receiver), and use the
    generic API to create repair symbols. This work should enable to
    provide feedback on the Generic API I-D.
-   T4.2: work on client (i.e., the decoding/receiving side): set up the
    UDP connection, use the generic API to manage source/repair symbols,
    to recover from erased source symbols. Test the whole
    transmission/reception chain. This work should enable to provide
    feedback on the Generic API I-D.

### Python wrapper:

-   T5.X:

### Python test and simulation applications:

-   T6.X:
